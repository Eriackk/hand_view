<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>hand_view_whiteboard</title>
  <style>
    body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", sans-serif; margin: 18px; }
    .wrap { max-width: 980px; margin: 0 auto; }
    .panel { position: relative; width: 100%; aspect-ratio: 16/9; background: #111; border-radius: 12px; overflow: hidden; }
    canvas { position: absolute; inset: 0; width: 100%; height: 100%; display: block; }
    .hud {
      position: relative;
      margin-top: 10px;
      color: #333;
      font-size: 14px;
      display: flex;
      gap: 14px;
      flex-wrap: wrap;
      align-items: center;
    }
    .badge { padding: 6px 10px; border: 1px solid #ddd; border-radius: 999px; background: #fff; }
    .hint { margin-top: 6px; color: #666; font-size: 13px; line-height: 1.5; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="panel">
      <canvas id="viewCanvas"></canvas>
      <canvas id="drawCanvas"></canvas>
    </div>
    <div class="hud">
      <span class="badge" id="status">状态：初始化中...</span>
      <span class="badge" id="mode">模式：--</span>
      <span class="badge" id="color">颜色：--</span>
      <span class="badge" id="tips">手势：捏合=画/停，五指张开=橡皮擦，OK=换颜色</span>
    </div>
    <div class="hint">说明：首次打开会弹出摄像头权限请求；画面做了镜像（更符合自拍）；如果你想清空画板，刷新页面即可（后续也可以加“清空”手势/按钮）。</div>
  </div>

  <video id="video" playsinline style="display:none;"></video>

  <script type="module">
    const viewCanvas = document.getElementById("viewCanvas");
    const drawCanvas = document.getElementById("drawCanvas");
    const vctx = viewCanvas.getContext("2d");
    const dctx = drawCanvas.getContext("2d");
    const video = document.getElementById("video");

    const statusEl = document.getElementById("status");
    const modeEl = document.getElementById("mode");
    const colorEl = document.getElementById("color");

    function setStatus(t) { statusEl.textContent = "状态：" + t; }
    function setMode(t) { modeEl.textContent = "模式：" + t; }
    function setColor(t) { colorEl.textContent = "颜色：" + t; }

    let stream = null;
    let rafId = null;

    // MediaPipe Tasks Web（动态加载，避免 CDN 失败导致整页脚本失效）
    let vision = null;
    let FilesetResolver = null;
    let HandLandmarker = null;
    let DrawingUtils = null;
    let handLandmarker = null;
    let drawingUtils = null;

    // 画板状态
    const COLORS = [
      { name: "红", value: "#ff3b30" },
      { name: "绿", value: "#34c759" },
      { name: "蓝", value: "#007aff" },
      { name: "黄", value: "#ffcc00" },
      { name: "白", value: "#ffffff" }
    ];
    let colorIndex = 0;
    let isDrawing = false;
    let isEraser = false;

    // 防抖：颜色切换手势触发“边沿检测”
    let okPrev = false;

    // 记录上一个笔尖位置，用于连线
    let prevPt = null;

    // 平滑（简单一阶滤波）
    let smoothPt = null;
    const SMOOTH_ALPHA = 0.35; // 越大越跟手，越小越稳

    function resizeCanvasesToVideo() {
      const w = video.videoWidth || 1280;
      const h = video.videoHeight || 720;
      if (viewCanvas.width !== w) viewCanvas.width = w;
      if (viewCanvas.height !== h) viewCanvas.height = h;
      if (drawCanvas.width !== w) drawCanvas.width = w;
      if (drawCanvas.height !== h) drawCanvas.height = h;
    }

    // 工具：欧式距离（归一化坐标）
    function dist2D(a, b) {
      const dx = a.x - b.x;
      const dy = a.y - b.y;
      return Math.sqrt(dx * dx + dy * dy);
    }

    // 估计手的尺度，用于阈值归一化（避免远近导致 pinch 阈值漂）
    // 用 wrist(0) 到 middle_mcp(9) 作为尺度
    function handScale(lm) {
      return Math.max(1e-6, dist2D(lm[0], lm[9]));
    }

    // 判定四指是否伸直：tip.y < pip.y 且 tip.y < mcp.y（在“手指朝上”的常见姿态下有效）
    function fingerExtended(lm, mcp, pip, tip) {
      return (lm[tip].y < lm[pip].y) && (lm[tip].y < lm[mcp].y);
    }

    // 判定拇指是否大致伸直：用角度近似（2-3-4 接近一条线）
    function angle(a, b, c) {
      const abx = a.x - b.x, aby = a.y - b.y;
      const cbx = c.x - b.x, cby = c.y - b.y;
      const dot = abx * cbx + aby * cby;
      const lab = Math.sqrt(abx * abx + aby * aby);
      const lcb = Math.sqrt(cbx * cbx + cby * cby);
      const cos = dot / Math.max(1e-6, lab * lcb);
      const clamped = Math.min(1, Math.max(-1, cos));
      return Math.acos(clamped) * 180 / Math.PI;
    }
    function thumbExtended(lm) {
      const a = angle(lm[2], lm[3], lm[4]); // 越接近 180 越直
      return a > 155;
    }

    // 捏合 pinch：拇指尖(4) 与 食指尖(8) 距离 / 手尺度 < 阈值
    function isPinch(lm) {
      const s = handScale(lm);
      const d = dist2D(lm[4], lm[8]) / s;
      return d < 0.35;
    }

    // 五指张开：四指伸直 + 拇指较直（阈值略松）
    function isOpenHand(lm) {
      const i = fingerExtended(lm, 5, 6, 8);
      const m = fingerExtended(lm, 9, 10, 12);
      const r = fingerExtended(lm, 13, 14, 16);
      const p = fingerExtended(lm, 17, 18, 20);
      const t = thumbExtended(lm);
      return i && m && r && p && t;
    }

    // OK 手势：pinch 成立 + 其余三指（中/无名/小指）伸直
    function isOK(lm) {
      const pinch = isPinch(lm);
      const m = fingerExtended(lm, 9, 10, 12);
      const r = fingerExtended(lm, 13, 14, 16);
      const p = fingerExtended(lm, 17, 18, 20);
      return pinch && m && r && p;
    }

    function normToPixel(pt) {
      // 注意：我们在画面做了镜像，所以 x 需要镜像映射
      const w = viewCanvas.width;
      const h = viewCanvas.height;
      const x = (1 - pt.x) * w;
      const y = pt.y * h;
      return { x, y };
    }

    function smoothPoint(pt) {
      if (!smoothPt) {
        smoothPt = { x: pt.x, y: pt.y };
        return smoothPt;
      }
      smoothPt.x = smoothPt.x + (pt.x - smoothPt.x) * SMOOTH_ALPHA;
      smoothPt.y = smoothPt.y + (pt.y - smoothPt.y) * SMOOTH_ALPHA;
      return smoothPt;
    }

    function drawStroke(pt) {
      // 画笔/橡皮擦
      if (!prevPt) prevPt = pt;

      dctx.save();
      dctx.lineCap = "round";
      dctx.lineJoin = "round";

      if (isEraser) {
        dctx.globalCompositeOperation = "destination-out";
        dctx.strokeStyle = "rgba(0,0,0,1)";
        dctx.lineWidth = 28;
      } else {
        dctx.globalCompositeOperation = "source-over";
        dctx.strokeStyle = COLORS[colorIndex].value;
        dctx.lineWidth = 6;
      }

      dctx.beginPath();
      dctx.moveTo(prevPt.x, prevPt.y);
      dctx.lineTo(pt.x, pt.y);
      dctx.stroke();
      dctx.restore();

      prevPt = pt;
    }

    async function initMediaPipe() {
      setStatus("加载 MediaPipe（JS/WASM/模型）...");
      vision = await import("https://unpkg.com/@mediapipe/tasks-vision@0.10.14");
      ({ FilesetResolver, HandLandmarker, DrawingUtils } = vision);

      const fileset = await FilesetResolver.forVisionTasks(
        "https://unpkg.com/@mediapipe/tasks-vision@0.10.14/wasm"
      );

      handLandmarker = await HandLandmarker.createFromOptions(fileset, {
        baseOptions: { modelAssetPath: "./hand_landmarker.task" },
        runningMode: "VIDEO",
        numHands: 2,
        minHandDetectionConfidence: 0.5,
        minHandPresenceConfidence: 0.5,
        minTrackingConfidence: 0.5
      });

      drawingUtils = new DrawingUtils(vctx);
      setStatus("MediaPipe 就绪");
    }

    async function openCamera() {
      setStatus("请求摄像头权限中...");
      stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: "user" },
        audio: false
      });
      video.srcObject = stream;
      await video.play();
      resizeCanvasesToVideo();
      setStatus("摄像头已开启，画板运行中");
    }

    function loop() {
      resizeCanvasesToVideo();

      // 1) 画摄像头画面到底层 viewCanvas（镜像）
      vctx.save();
      vctx.clearRect(0, 0, viewCanvas.width, viewCanvas.height);
      vctx.translate(viewCanvas.width, 0);
      vctx.scale(-1, 1);
      vctx.drawImage(video, 0, 0, viewCanvas.width, viewCanvas.height);

      // 2) 推理
      const nowMs = performance.now();
      const result = handLandmarker.detectForVideo(video, nowMs);

      // 默认状态
      let foundHand = false;
      let pinchNow = false;
      let openNow = false;
      let okNow = false;

      if (result.landmarks && result.landmarks.length > 0) {
        // 取第一只手做画笔（你也可以扩展为两手不同功能）
        const lm = result.landmarks[0];
        foundHand = true;

        pinchNow = isPinch(lm);
        openNow = isOpenHand(lm);
        okNow = isOK(lm);

        // 画骨架（在底层 viewCanvas 上）
        drawingUtils.drawConnectors(lm, HandLandmarker.HAND_CONNECTIONS);
        drawingUtils.drawLandmarks(lm, { radius: 3 });

        // 3) 模式逻辑
        // 五指张开：橡皮擦优先级最高
        isEraser = openNow;

        // OK 手势：切换颜色（边沿触发，避免每帧狂切）
        if (okNow && !okPrev) {
          colorIndex = (colorIndex + 1) % COLORS.length;
        }
        okPrev = okNow;

        // 捏合：画/停
        // 这里做“边沿控制”：pinch 从 false->true 开始画，true->false 停止画
        if (pinchNow && !isDrawing) {
          isDrawing = true;
          prevPt = null;
          smoothPt = null;
        } else if (!pinchNow && isDrawing) {
          isDrawing = false;
          prevPt = null;
          smoothPt = null;
        }

        // 4) 画笔位置：食指尖(8)
        if (isDrawing) {
          const tipPx = normToPixel(lm[8]);
          const sp = smoothPoint(tipPx);
          drawStroke(sp);
        }
      } else {
        // 没检测到手：停止绘制，避免断线飞笔
        isDrawing = false;
        isEraser = false;
        prevPt = null;
        smoothPt = null;
        okPrev = false;
      }

      vctx.restore();

      // HUD
      if (!foundHand) setMode("未检测到手");
      else if (isEraser) setMode(isDrawing ? "橡皮擦（捏合中）" : "橡皮擦（松开）");
      else setMode(isDrawing ? "画笔（捏合中）" : "画笔（松开）");
      setColor(COLORS[colorIndex].name);

      rafId = requestAnimationFrame(loop);
    }

    async function main() {
      try {
        // 先初始化识别，再开摄像头，避免开了摄像头却没法推理
        await initMediaPipe();
        await openCamera();
        setMode("等待手势");
        setColor(COLORS[colorIndex].name);
        loop();
      } catch (e) {
        console.error(e);
        const msg = String(e).toLowerCase();
        if (msg.includes("permission") || msg.includes("denied")) setStatus("摄像头权限被拒绝（请在地址栏相机权限里允许）");
        else if (msg.includes("hand_landmarker.task")) setStatus("模型加载失败（确认 hand_landmarker.task 与 index.html 同目录且文件名一致）");
        else setStatus("初始化失败（可能是网络/CDN/WASM，打开控制台看第一条报错）");
      }
    }

    window.addEventListener("beforeunload", () => {
      if (rafId) cancelAnimationFrame(rafId);
      if (stream) stream.getTracks().forEach(t => t.stop());
    });

    main();
  </script>
</body>
</html>
