
<body>
 <div class="wrap">
 <div class="panel" id="panel">
 <canvas id="viewCanvas"></canvas>
 <canvas id="drawCanvas"></canvas>
 </div>
 <div class="hud">
 <span class="badge" id="status">状态' 初始化中...</span>
 <span class="badge" id="mode">模式' --</span>
 <span class="badge" id="res">分辨率' --</span>
 </div>
 <div class="hint">
 ⼿势说明' 仅⻝指伸直=画笔 a红⾊de ⻝指+中指伸直=区域橡⽪擦｡ <br>
 说明' 全程本地运⾏r 不上传视频e ⻚⾯做了镜像显示e 如果画⾯⽐例不对r
刷新⼀次即可重新⾃适应｡
 </div>
 </div>
 <video id="video" playsinline style="display:none;"></
video>
 <script type="module">
 const panel = document.getElementById("panel");
 const viewCanvas = 
document.getElementById("viewCanvas");
 const drawCanvas = 
document.getElementById("drawCanvas");
 const vctx = viewCanvas.getContext("2d");
 const dctx = drawCanvas.getContext("2d");
 const video = document.getElementById("video");
 const statusEl = document.getElementById("status");
 const modeEl = document.getElementById("mode");
 const resEl = document.getElementById("res");
 function setStatus(t) { statusEl.textContent = "状态' " + 
t; }
 function setMode(t) { modeEl.textContent = "模式' " + 
t; }
 function setRes(t) { resEl.textContent = "分辨率' " + t; }
 let stream = null;
 let rafId = null;
 // MediaPipe Tasks Web a动态加载d
let vision = null;
 let FilesetResolver = null;
 let HandLandmarker = null;
 let DrawingUtils = null;
 let handLandmarker = null;
 let drawingUtils = null;
 // 画板状态
 const PEN_COLOR = "#ff3b30"; // 固定红⾊
 const PEN_WIDTH = 7;
 const ERASER_RADIUS = 26; // 区域橡⽪擦半径
 const SMOOTH_ALPHA = 0.45; // 越⼤越跟⼿r 越⼩越稳
 let smoothPt = null; // 平滑后的像素坐标
 let prevPt = null; // 上笔尖像素坐标
 let lastSeenTs = 0; // 最近⼀次检测到⼿的时间戳 a⽤于
抗掉帧d
 const HOLD_MS = 180; // 短暂丢⼿时继续“黏住”笔尖r 减
少断笔
 // 计算视频绘制矩形' 保持⽐例不拉伸 acontaind
 function calcContainRect(srcW, srcH, dstW, dstH) {
 const srcAR = srcW / srcH;
 const dstAR = dstW / dstH;
 let w, h, x, y;
 if (srcAR > dstAR) {
 w = dstW;
 h = Math.round(dstW / srcAR);
 x = 0;
 y = Math.round((dstH - h) / 2);
 } else {
 h = dstH;
 w = Math.round(dstH * srcAR);
 y = 0;
 x = Math.round((dstW - w) / 2);
 }
 return { x, y, w, h };
 }
 // canvas 尺⼨与⾯板⽐例⾃适应视频r 避免“压缩整个⼈”
 function resizeToVideo() {
 const vw = video.videoWidth || 1280;
 const vh = video.videoHeight || 720;
 // ⾯板按视频⽐例⾃适应 a关键' 不再固定 16/9d
 panel.style.aspectRatio = `${vw} / ${vh}`;
if (viewCanvas.width !== vw) viewCanvas.width = vw;
 if (viewCanvas.height !== vh) viewCanvas.height = vh;
 if (drawCanvas.width !== vw) drawCanvas.width = vw;
 if (drawCanvas.height !== vh) drawCanvas.height = vh;
 setRes(`${vw}×${vh}`);
 }
 // 归⼀化点 -> 像素点 a注意我们做镜像显示r 所以 x 需要镜像d
 function normToPixel(pt, w, h) {
 return { x: (1 - pt.x) * w, y: pt.y * h };
 }
 function smoothPoint(pt) {
 if (!smoothPt) {
 smoothPt = { x: pt.x, y: pt.y };
 return smoothPt;
 }
 smoothPt.x = smoothPt.x + (pt.x  smoothPt.x) * 
SMOOTH_ALPHA;
 smoothPt.y = smoothPt.y + (pt.y - smoothPt.y) * 
SMOOTHALPHA;
 return smoothPt;
 }
 // 画笔' 做“插值补点”r 解决短短续续
 function drawLineInterpolated(from, to) {
 const dx = to.x - from.x;
 const dy = to.y - from.y;
 const dist = Math.sqrt(dx*dx + dy*dy);
 // 每 3 像素补⼀个点 a越⼩越密越连续d
 const step = 3;
 const n = Math.max(1, Math.floor(dist / step));
 dctx.save();
 dctx.globalCompositeOperation = "source-over";
 dctx.strokeStyle = PEN_COLOR;
 dctx.lineWidth = PEN_WIDTH;
 dctx.lineCap = "round";
 dctx.lineJoin = "round";
 dctx.beginPath();
 dctx.moveTo(from.x, from.y);
 for (let i = 1; i <= n; i++) {
 const t = i / n;
dctx.lineTo(from.x + dx * t, from.y + dy * t);
 }
 dctx.stroke();
 dctx.restore();
 }
 // 区域橡⽪擦' 沿着移动路径“擦⼀条带”
 function eraseAlong(from, to) {
 const dx = to.x - from.x;
 const dy = to.y - from.y;
 const dist = Math.sqrt(dx*dx + dy*dy);
 const step = 4;
 const n = Math.max(1, Math.floor(dist / step));
 dctx.save();
 dctx.globalCompositeOperation = "destination-out";
 dctx.fillStyle = "rgba(0,0,0,1)";
 for (let i = 0; i <= n; i++) {
 const t = i / n;
 const x = from.x + dx * t;
 const y = from.y + dy * t;
 dctx.beginPath();
 dctx.arc(x, y, ERASER_RADIUS, 0, Math.PI * 2);
 dctx.fill();
 }
 dctx.restore();
 }
 // ⼿指伸直判定 a适合“⼿指⼤致朝上”的交互姿态d
 function fingerExtended(lm, mcp, pip, tip) {
 return (lm[tip].y < lm[pip].y) && (lm[tip].y < 
lm[mcp].y);
 }
 // 判定“仅⻝指伸直”' index=truer middle/ring/pinky=false a拇
指不强约束d
 function isOnlyIndex(lm) {
 const index = fingerExtended(lm, 5, 6, 8);
 const middle = fingerExtended(lm, 9, 10, 12);
 const ring = fingerExtended(lm, 13, 14, 16);
 const pinky = fingerExtended(lm, 17, 18, 20);
 return index && !middle && !ring && !pinky;
 }
 // 判定“⻝指+中指伸直”' index=true middle=true ring/
pinky=false
 function isIndexMiddle(lm) {
 const index = fingerExtended(lm, 5, 6, 8);
 const middle = fingerExtended(lm, 9, 10, 12);
 const ring = fingerExtended(lm, 13, 14, 16);
 const pinky = fingerExtended(lm, 17, 18, 20);
 return index && middle && !ring && !pinky;
 }
 async function initMediaPipe() {
 setStatus("加载 MediaPipe aJS/WASM/模型d...");
 vision = await import("https://unpkg.com/@mediapipe/
tasks-vision@0.10.14");
 ({ FilesetResolver, HandLandmarker, DrawingUtils } = 
vision);
 const fileset = await FilesetResolver.forVisionTasks(
 "https://unpkg.com/@mediapipe/tasks-vision@0.10.14/
wasm"
 );
 handLandmarker = await 
HandLandmarker.createFromOptions(fileset, {
 baseOptions: { modelAssetPath: "./
hand_landmarker.task" },
 runningMode: "VIDEO",
 numHands: 1, // 画板先⽤单⼿更稳
 minHandDetectionConfidence: 0.5,
 minHandPresenceConfidence: 0.5,
 minTrackingConfidence: 0.5
 });
 drawingUtils = new DrawingUtils(vctx);
 setStatus("MediaPipe 就绪");
 }
 async function openCamera() {
 setStatus("请求摄像头权限中...");
 stream = await navigator.mediaDevices.getUserMedia({
 video: {
 facingMode: "user",
 width: { ideal: 1920 },
 height: { ideal: 1080 },
 frameRate: { ideal: 30, max: 60 }
 },
 audio: false
 });
video.srcObject = stream;
 await video.play();
 resizeToVideo();
 setStatus("摄像头已开启r 运⾏中");
 setMode("等待⼿势");
 }
 function loop() {
 // 保险' 有些浏览器 videoWidth/Height 会晚⼀拍
 if (video.videoWidth && video.videoHeight) 
resizeToVideo();
 const W = viewCanvas.width;
 const H = viewCanvas.height;
 // 1) 背景⿊⾊ a你要求的背景换⿊d
 vctx.save();
 vctx.clearRect(0, 0, W, H);
 vctx.fillStyle = "#000";
 vctx.fillRect(0, 0, W, H);
 // 2) 画摄像头' 保持⽐例不拉伸 acontaindr 并镜像
 const rect = calcContainRect(video.videoWidth || W, 
video.videoHeight || H, W, H);
 vctx.translate(W, 0);
 vctx.scale(-1, 1);
 vctx.drawImage(video, rect.x, rect.y, rect.w, rect.h);
 vctx.restore();
 // 3) 推理
 const now = performance.now();
 const result = handLandmarker.detectForVideo(video, 
now);
 let hasHand = false;
 let mode = "等待⼿势";
 if (result.landmarks && result.landmarks.length > 0) {
 hasHand = true;
 lastSeenTs = now;
 const lm = result.landmarks[0];
 // 画⻣架 a叠加在 viewCanvas 上d
 vctx.save();
vctx.translate(W, 0);
 vctx.scale(-1, 1);
 drawingUtils.drawConnectors(lm, 
HandLandmarker.HAND_CONNECTIONS);
 drawingUtils.drawLandmarks(lm, { radius: 3 });
 vctx.restore();
 const drawOn = isOnlyIndex(lm);
 const eraseOn = isIndexMiddle(lm);
 // ⽤⻝指尖当笔尖
 const tipPx = normToPixel(lm[8], W, H);
 const sp = smoothPoint(tipPx);
 if (drawOn) {
 mode = "画笔 a仅⻝指伸直d";
 if (!prevPt) prevPt = { x: sp.x, y: sp.y };
 drawLineInterpolated(prevPt, sp);
 prevPt = { x: sp.x, y: sp.y };
 } else if (eraseOn) {
 mode = "区域橡⽪擦 a⻝指+中指d";
 if (!prevPt) prevPt = { x: sp.x, y: sp.y };
 eraseAlong(prevPt, sp);
 prevPt = { x: sp.x, y: sp.y };
 } else {
 // ⾮绘制/⾮擦除姿态' 抬笔
 prevPt = null;
 smoothPt = null;
 }
 } else {
 // 没检测到⼿' 短时间 HOLD 以减少断笔e 超过就抬笔
 if (now - lastSeenTs > HOLD_MS) {
 prevPt = null;
 smoothPt = null;
 }
 mode = "未检测到⼿";
 }
 setMode(mode);
 rafId = requestAnimationFrame(loop);
 }
 async function main() {
 try {
 await initMediaPipe();
 await openCamera();
 loop();
} catch (e) {
 console.error(e);
 const msg = String(e).toLowerCase();
 if (msg.includes("permission") || 
msg.includes("denied")) setStatus("摄像头权限被拒绝 a请在地址栏相机
权限⾥允许d");
 else if (msg.includes("hand_landmarker.task")) 
setStatus("模型加载失败 a确认 hand_landmarker.task 与 index.html 
同⽬录且⽂件名致d");
 else setStatus("初始化失败 a可能是⽹络/CDN/WASMr 打开控制台
看第⼀条报错d");
 }
 }
 window.addEventListener("beforeunload", () => {
 if (rafId) cancelAnimationFrame(rafId);
 if (stream) stream.getTracks().forEach(t => t.stop());
 });
 main();
 </script>
</body>
</html>
