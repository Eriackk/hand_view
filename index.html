<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="utf-8">
<title>Hand View Whiteboard</title>
<style>
html,body{margin:0;height:100%;background:#111;color:#ddd;font-family:sans-serif}
.app{display:flex;height:100%}
.left,.right{width:260px;padding:12px;box-sizing:border-box}
.center{flex:1;display:flex;justify-content:center;align-items:center}
.panel{position:relative;width:100%;height:100%}
.panel canvas{position:absolute;inset:0;width:100%;height:100%}
label{font-size:13px;display:block;margin-top:10px}
input[type=range]{width:100%}
button{width:100%;margin-top:8px}
</style>
</head>

<body>
<div class="app">
  <div class="left">
    <b>功能说明</b><br>
    写字：双手 + 控制手拳头<br>
    停笔：控制手食指伸直<br>
    回退：停笔态下 食指+中指<br>
    橡皮擦：单手 食指+中指<br>
    导出：选择区域
  </div>

  <div class="center">
    <div class="panel">
      <canvas id="viewCanvas"></canvas>
      <canvas id="drawCanvas"></canvas>
      <canvas id="uiCanvas"></canvas>
    </div>
  </div>

  <div class="right">
    <label>笔宽 <span id="wVal">3.5</span></label>
    <input id="widthSlider" type="range" min="1" max="12" step="0.5" value="3.5">

    <label>橡皮擦大小 <span id="eVal">40</span></label>
    <input id="eraserSlider" type="range" min="10" max="120" step="1" value="40">

    <button id="exportBtn">选择区域导出 PNG</button>
  </div>
</div>

<script type="module">
import vision from "https://unpkg.com/@mediapipe/tasks-vision@0.10.3";
const {HandLandmarker, FilesetResolver} = vision;

const view = document.getElementById("viewCanvas");
const draw = document.getElementById("drawCanvas");
const ui   = document.getElementById("uiCanvas");
const vctx=view.getContext("2d");
const dctx=draw.getContext("2d");

const DPR=window.devicePixelRatio||1;
function resize(){
  for(const c of [view,draw,ui]){
    c.width=c.clientWidth*DPR;
    c.height=c.clientHeight*DPR;
  }
}
window.onresize=resize; resize();

let penWidth=3.5;
let eraserSize=40;
widthSlider.oninput=e=>{penWidth=+e.target.value;wVal.textContent=penWidth};
eraserSlider.oninput=e=>{eraserSize=+e.target.value;eVal.textContent=eraserSize};

const MAX_UNDO=10;
let undoStack=[];
function pushUndo(){
  if(undoStack.length>=MAX_UNDO) undoStack.shift();
  undoStack.push(dctx.getImageData(0,0,draw.width,draw.height));
}
function undo(){
  if(!undoStack.length) return;
  dctx.putImageData(undoStack.pop(),0,0);
}

const palmConnections=[[0,1],[1,5],[5,9],[9,13],[13,17],[17,0]];
const fingerConnections=[
[1,2],[2,3],[3,4],
[5,6],[6,7],[7,8],
[9,10],[10,11],[11,12],
[13,14],[14,15],[15,16],
[17,18],[18,19],[19,20]
];

function drawSkeleton(lm){
  vctx.lineCap="round";
  function line(a,b,color,w){
    vctx.strokeStyle=color;vctx.lineWidth=w;
    vctx.beginPath();
    vctx.moveTo(lm[a].x*view.width,lm[a].y*view.height);
    vctx.lineTo(lm[b].x*view.width,lm[b].y*view.height);
    vctx.stroke();
  }
  function dot(i,color,r){
    vctx.fillStyle=color;
    vctx.beginPath();
    vctx.arc(lm[i].x*view.width,lm[i].y*view.height,r,0,Math.PI*2);
    vctx.fill();
  }
  palmConnections.forEach(([a,b])=>line(a,b,"#000",7));
  palmConnections.flat().forEach(i=>dot(i,"#000",6));
  fingerConnections.forEach(([a,b])=>line(a,b,"#fff",5));
  fingerConnections.flat().forEach(i=>dot(i,"#fff",4));
}

function isUp(lm,i){return lm[i].y<lm[i-2].y}
function onlyIndex(lm){return isUp(lm,8)&&!isUp(lm,12)}
function indexMiddle(lm){return isUp(lm,8)&&isUp(lm,12)}

let lastPt=null;
let undoLatch=false;

function drawStroke(pt){
  if(!lastPt){pushUndo();lastPt=pt;return;}
  const dx=pt.x-lastPt.x,dy=pt.y-lastPt.y;
  const dist=Math.hypot(dx,dy);
  const steps=Math.max(1,Math.floor(dist/4));
  for(let i=1;i<=steps;i++){
    const t=i/steps;
    const x=lastPt.x+dx*t,y=lastPt.y+dy*t;
    dctx.strokeStyle="#b19d36";
    dctx.lineWidth=penWidth;
    dctx.lineCap="round";
    dctx.beginPath();
    dctx.moveTo(lastPt.x,lastPt.y);
    dctx.quadraticCurveTo(lastPt.x,lastPt.y,x,y);
    dctx.stroke();
    lastPt={x,y};
  }
}

const resolver=await FilesetResolver.forVisionTasks(
  "https://unpkg.com/@mediapipe/tasks-vision@0.10.3/wasm");
const landmarker=await HandLandmarker.createFromOptions(resolver,{
  baseOptions:{modelAssetPath:"./hand_landmarker.task"},
  runningMode:"VIDEO",
  numHands:2
});

const video=document.createElement("video");
video.autoplay=true;
video.srcObject=await navigator.mediaDevices.getUserMedia({video:true});

async function loop(){
  vctx.clearRect(0,0,view.width,view.height);
  vctx.drawImage(video,0,0,view.width,view.height);
  const res=await landmarker.detectForVideo(video,performance.now());
  if(res.landmarks){
    if(res.landmarks.length===1){
      const lm=res.landmarks[0];
      drawSkeleton(lm);
      if(indexMiddle(lm)){
        dctx.save();
        dctx.globalCompositeOperation="destination-out";
        dctx.beginPath();
        dctx.arc(lm[8].x*draw.width,lm[8].y*draw.height,eraserSize,0,Math.PI*2);
        dctx.fill();
        dctx.restore();
      }
    }
    if(res.landmarks.length===2){
      const lm=res.landmarks[0];
      drawSkeleton(lm);
      if(onlyIndex(lm)){
        if(indexMiddle(lm)){
          if(!undoLatch){undo();undoLatch=true;}
        }else undoLatch=false;
      }else{
        const x=(lm[8].x+lm[12].x)/2*draw.width;
        const y=(lm[8].y+lm[12].y)/2*draw.height;
        drawStroke({x,y});
        vctx.fillStyle="#fff";
        vctx.beginPath();
        vctx.arc(x,y,6,0,Math.PI*2);
        vctx.fill();
      }
    }
  }
  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
