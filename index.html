】<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>hand_view_whiteboard</title>
  <style>
    :root{
      --bg:#000; --fg:#eee;
      --card:rgba(255,255,255,0.08);
      --card2:rgba(255,255,255,0.10);
      --bd:rgba(255,255,255,0.12);
      --bd2:rgba(255,255,255,0.18);
      --bd3:rgba(255,255,255,0.28);
      --mut:rgba(255,255,255,0.72);
    }
    *{ box-sizing:border-box; }
    body{ margin:0; background:var(--bg); color:var(--fg); font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"PingFang SC","Hiragino Sans GB","Microsoft YaHei",sans-serif; }
    .app{
      min-height:100vh;
      display:grid;
      grid-template-columns: 360px 1fr 360px;
      gap:16px;
      padding:16px;
      align-items:start;
    }
    @media (max-width: 1180px){
      .app{ grid-template-columns: 320px 1fr 320px; }
    }
    @media (max-width: 980px){
      .app{ grid-template-columns: 1fr; }
      .left,.right{ order:2; }
      .center{ order:1; }
    }

    .box{
      border-radius:14px;
      background:rgba(255,255,255,0.06);
      border:1px solid rgba(255,255,255,0.10);
      padding:12px;
    }
    .boxTitle{ font-size:13px; color:rgba(255,255,255,0.85); margin:0 0 10px 0; }
    .help{ font-size:12.5px; color:var(--mut); line-height:1.6; margin:0; }
    .spacer{
      margin-top:12px;
      min-height:240px;
      border-radius:12px;
      border:1px dashed rgba(255,255,255,0.18);
      background:rgba(255,255,255,0.03);
    }

    .center{ display:flex; flex-direction:column; align-items:center; gap:10px; }
    .panel{
      width: min(1100px, 100%);
      position:relative;
      background:#000;
      border-radius:14px;
      overflow:hidden;
      box-shadow:0 0 0 1px rgba(255,255,255,0.08) inset;
    }
    canvas{ position:absolute; inset:0; width:100%; height:100%; display:block; }

    .statusbar{
      width: min(1100px, 100%);
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:flex-start;
      padding:10px 12px;
      border-radius:12px;
      background:rgba(255,255,255,0.06);
      border:1px solid rgba(255,255,255,0.10);
    }
    .badge{
      padding:6px 10px;
      border-radius:999px;
      background:var(--card);
      border:1px solid var(--bd);
      font-size:13px;
      color:var(--fg);
      white-space:nowrap;
    }

    .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    .btn{
      padding:8px 12px;
      border-radius:10px;
      background:var(--card2);
      border:1px solid var(--bd2);
      color:var(--fg);
      font-size:13px;
      cursor:pointer;
      user-select:none;
    }
    .btn:hover{ background:rgba(255,255,255,0.14); }
    .btn.on{ background:rgba(255,255,255,0.18); border-color:var(--bd3); }
    .btn:disabled{ opacity:0.45; cursor:not-allowed; }

    .ctl{
      display:flex;
      align-items:center;
      gap:10px;
      width:100%;
      padding:10px 10px;
      border-radius:12px;
      background:var(--card);
      border:1px solid var(--bd);
    }
    .ctl label{ font-size:13px; color:rgba(255,255,255,0.85); width:56px; }
    input[type="range"]{ flex:1; }
    input[type="color"]{ width:44px; height:32px; border:0; background:transparent; padding:0; cursor:pointer; }
  </style>
</head>
<body>
  <div class="app">
    <div class="left">
      <div class="box">
        <p class="boxTitle">功能说明</p>
        <p class="help" id="helpText">
          写字：双手检测到且出现“控制手”为拳头时，另一只手写字；笔尖=写字手食指尖(8)与中指尖(12)中点；为减抖，位置平滑系数采用较强平滑（SMOOTH_ALPHA=0.30）。<br>
          停笔：写字过程中，控制手从拳头变为张开掌（Open Palm）即停笔（断开，不连线）。<br>
          撤回：写字过程中，控制手从拳头变为“仅食指伸直（Index-only）”触发一次撤回（边沿触发+冷却）。<br>
          橡皮擦：仅单手且为拳头时启用，中心=食指尖(8)，较大半径擦除，可撤回。<br>
          导出：进入选择区域模式后鼠标框选，导出PNG时先填充背景（白/黑）再叠加笔迹层，导出不清画布；选择模式下暂停手势。
        </p>
        <div class="spacer" title="预留区域（未来：打字等功能按钮）"></div>
      </div>
    </div>

    <div class="center">
      <div class="panel" id="panel">
        <canvas id="viewCanvas"></canvas>
        <canvas id="drawCanvas"></canvas>
        <canvas id="uiCanvas"></canvas>
      </div>
      <div class="statusbar">
        <span class="badge" id="state">判断：初始化中...</span>
        <span class="badge" id="sel">选择：--</span>
      </div>
    </div>

    <div class="right">
      <div class="box">
        <p class="boxTitle">颜色 / 笔宽 / 导出</p>

        <div class="ctl">
          <label>颜色</label>
          <input id="colorPick" type="color" value="#30d158" title="颜色选择器" />
          <span class="badge" id="colText" style="margin-left:auto;">#30d158</span>
        </div>

        <div class="row" style="margin-top:10px;">
          <button class="btn" id="cBlack" type="button" data-col="#000000">黑</button>
          <button class="btn" id="cWhite" type="button" data-col="#ffffff">白</button>
          <button class="btn" id="cRed" type="button" data-col="#ff3b30">红</button>
          <button class="btn" id="cYellow" type="button" data-col="#ffd60a">黄</button>
          <button class="btn" id="cBlue" type="button" data-col="#0a84ff">蓝</button>
          <button class="btn" id="cGreen" type="button" data-col="#30d158">绿</button>
        </div>

        <div class="ctl" style="margin-top:10px;">
          <label>笔宽</label>
          <input id="penRange" type="range" min="1" max="30" step="0.5" value="3.5" />
          <span class="badge" id="penVal">3.5</span>
        </div>

        <div class="row" style="margin-top:10px;">
          <button class="btn" id="undoBtn" type="button">撤回</button>
          <button class="btn" id="clearBtn" type="button">清空</button>
        </div>

        <div class="row" style="margin-top:10px;">
          <button class="btn" id="selectBtn" type="button">选择区域导出</button>
          <button class="btn" id="bgWhiteBtn" type="button">背景：白</button>
          <button class="btn" id="bgBlackBtn" type="button">背景：黑</button>
        </div>

        <div class="row" style="margin-top:10px;">
          <button class="btn" id="exportBtn" type="button" disabled>导出 PNG</button>
          <button class="btn" id="cancelSelectBtn" type="button" disabled>取消选择</button>
        </div>
      </div>
    </div>
  </div>

  <video id="video" playsinline style="display:none;"></video>

  <script type="module">
    const panel = document.getElementById("panel");
    const viewCanvas = document.getElementById("viewCanvas");
    const drawCanvas = document.getElementById("drawCanvas");
    const uiCanvas = document.getElementById("uiCanvas");
    const vctx = viewCanvas.getContext("2d");
    const dctx = drawCanvas.getContext("2d");
    const uctx = uiCanvas.getContext("2d");
    const video = document.getElementById("video");

    const stateEl = document.getElementById("state");
    const selEl = document.getElementById("sel");

    const clearBtn = document.getElementById("clearBtn");
    const undoBtn = document.getElementById("undoBtn");

    const penRange = document.getElementById("penRange");
    const penVal = document.getElementById("penVal");

    const colorPick = document.getElementById("colorPick");
    const colText = document.getElementById("colText");
    const colorBtns = ["cBlack","cWhite","cRed","cYellow","cBlue","cGreen"].map(id => document.getElementById(id));

    const selectBtn = document.getElementById("selectBtn");
    const bgWhiteBtn = document.getElementById("bgWhiteBtn");
    const bgBlackBtn = document.getElementById("bgBlackBtn");
    const exportBtn = document.getElementById("exportBtn");
    const cancelSelectBtn = document.getElementById("cancelSelectBtn");

    function setState(t){ stateEl.textContent = "判断：" + t; }
    function setSel(t){ selEl.textContent = "选择：" + t; }

    let stream=null, rafId=null;
    let vision=null, FilesetResolver=null, HandLandmarker=null, DrawingUtils=null;
    let handLandmarker=null, drawingUtils=null;

    // 方案A：更强平滑减少抖动（越小越稳但更“黏”）
    const SMOOTH_ALPHA = 0.30;
    const HOLD_MS = 420;
    const INTERP_STEP = 2;

    // 橡皮擦
    const ERASER_RADIUS = 26;

    let smoothPt=null, prevPt=null, lastSeenTs=0;

    // 手动笔宽+颜色
    let penW = Number(penRange.value);
    let penColor = colorPick.value;

    // Undo 栈
    const MAX_UNDO = 30;
    const undoStack = [];
    const UNDO_COOLDOWN_MS = 700;
    let lastUndoTs = -Infinity;

    // 区域选择导出
    let selecting=false;
    let bgColor="#ffffff";
    let sel=null; // {x0,y0,x1,y1} canvas像素
    let drag=null;

    // 写字会话：锁定“控制手”（原拳头手）的左右手标签，避免手序抖动
    let writingSession = {
      active:false,
      controlLabel:null, // "Left"/"Right"/null
      lastControlState:"none" // "fist" | "index" | "open" | "other" | "none"
    };

    function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

    function resizeToVideo(){
      const vw = video.videoWidth || 1280;
      const vh = video.videoHeight || 720;
      panel.style.aspectRatio = `${vw} / ${vh}`;
      if (viewCanvas.width !== vw) viewCanvas.width = vw;
      if (viewCanvas.height !== vh) viewCanvas.height = vh;
      if (drawCanvas.width !== vw) drawCanvas.width = vw;
      if (drawCanvas.height !== vh) drawCanvas.height = vh;
      if (uiCanvas.width !== vw) uiCanvas.width = vw;
      if (uiCanvas.height !== vh) uiCanvas.height = vh;
    }

    // 镜像：x 取 1-x
    function normToPixel(pt, w, h){ return { x:(1-pt.x)*w, y:pt.y*h }; }

    function smoothPoint(pt){
      if(!smoothPt){ smoothPt={x:pt.x,y:pt.y}; return smoothPt; }
      smoothPt.x = smoothPt.x + (pt.x - smoothPt.x)*SMOOTH_ALPHA;
      smoothPt.y = smoothPt.y + (pt.y - smoothPt.y)*SMOOTH_ALPHA;
      return smoothPt;
    }

    // 无黑边：cover（保持比例，必要时裁切）
    function calcCoverRect(srcW, srcH, dstW, dstH){
      const srcAR = srcW/srcH;
      const dstAR = dstW/dstH;
      let w,h,x,y;
      if(srcAR > dstAR){
        h = dstH;
        w = Math.round(dstH*srcAR);
        x = Math.round((dstW-w)/2);
        y = 0;
      }else{
        w = dstW;
        h = Math.round(dstW/srcAR);
        x = 0;
        y = Math.round((dstH-h)/2);
      }
      return {x,y,w,h};
    }

    function drawLineInterpolated(from,to,width,color){
      const dx=to.x-from.x, dy=to.y-from.y;
      const dist=Math.sqrt(dx*dx+dy*dy);
      const n=Math.max(1, Math.floor(dist/INTERP_STEP));
      dctx.save();
      dctx.globalCompositeOperation="source-over";
      dctx.strokeStyle=color;
      dctx.lineWidth=width;
      dctx.lineCap="round";
      dctx.lineJoin="round";
      dctx.beginPath();
      dctx.moveTo(from.x, from.y);
      for(let i=1;i<=n;i++){
        const t=i/n;
        dctx.lineTo(from.x+dx*t, from.y+dy*t);
      }
      dctx.stroke();
      dctx.restore();
    }

    function eraseAt(pt){
      dctx.save();
      dctx.globalCompositeOperation="destination-out";
      dctx.beginPath();
      dctx.arc(pt.x, pt.y, ERASER_RADIUS, 0, Math.PI*2);
      dctx.fill();
      dctx.restore();
    }

    function fingerExtended(lm,mcp,pip,tip){
      return (lm[tip].y < lm[pip].y) && (lm[tip].y < lm[mcp].y);
    }
    function isFist(lm){
      const index = fingerExtended(lm,5,6,8);
      const middle = fingerExtended(lm,9,10,12);
      const ring = fingerExtended(lm,13,14,16);
      const pinky = fingerExtended(lm,17,18,20);
      return !index && !middle && !ring && !pinky;
    }
    function isOpenPalm(lm){
      const index = fingerExtended(lm,5,6,8);
      const middle = fingerExtended(lm,9,10,12);
      const ring = fingerExtended(lm,13,14,16);
      const pinky = fingerExtended(lm,17,18,20);
      return index && middle && ring && pinky;
    }
    function isIndexOnly(lm){
      const index = fingerExtended(lm,5,6,8);
      const middle = fingerExtended(lm,9,10,12);
      const ring = fingerExtended(lm,13,14,16);
      const pinky = fingerExtended(lm,17,18,20);
      return index && !middle && !ring && !pinky;
    }

    function indexMiddleMidpointPx(lm,W,H){
      const p8 = normToPixel(lm[8],W,H);
      const p12 = normToPixel(lm[12],W,H);
      return { x:(p8.x+p12.x)*0.5, y:(p8.y+p12.y)*0.5 };
    }
    function indexTipPx(lm,W,H){
      return normToPixel(lm[8],W,H);
    }

    function pushUndoSnapshot(){
      try{
        const img = dctx.getImageData(0,0,drawCanvas.width,drawCanvas.height);
        undoStack.push(img);
        if(undoStack.length>MAX_UNDO) undoStack.shift();
      }catch(e){}
    }
    function doUndo(){
      if(!undoStack.length) return;
      const img = undoStack.pop();
      dctx.putImageData(img,0,0);
      prevPt=null; smoothPt=null;
    }

    function syncSelText(){
      penVal.textContent = penW.toFixed(1);
      colText.textContent = penColor.toLowerCase();
      setSel(`笔宽 ${penW.toFixed(1)} | 颜色 ${penColor.toLowerCase()} | 导出背景 ${bgColor==="#ffffff"?"白":"黑"} | 选择模式 ${selecting?"开":"关"}`);
    }

    penRange.addEventListener("input", ()=>{
      penW = Number(penRange.value);
      syncSelText();
    });

    function setActiveColorBtn(hex){
      for(const b of colorBtns){
        b.classList.toggle("on", (b.dataset.col||"").toLowerCase()===hex.toLowerCase());
      }
    }
    for(const b of colorBtns){
      b.addEventListener("click", ()=>{
        penColor = b.dataset.col;
        colorPick.value = penColor;
        setActiveColorBtn(penColor);
        syncSelText();
      });
    }
    colorPick.addEventListener("input", ()=>{
      penColor = colorPick.value;
      setActiveColorBtn(penColor);
      syncSelText();
    });

    function setBgButtons(){
      bgWhiteBtn.classList.toggle("on", bgColor==="#ffffff");
      bgBlackBtn.classList.toggle("on", bgColor==="#000000");
    }
    bgWhiteBtn.addEventListener("click", ()=>{ bgColor="#ffffff"; setBgButtons(); syncSelText(); });
    bgBlackBtn.addEventListener("click", ()=>{ bgColor="#000000"; setBgButtons(); syncSelText(); });

    undoBtn.addEventListener("click", ()=>doUndo());
    clearBtn.addEventListener("click", ()=>{
      dctx.clearRect(0,0,drawCanvas.width,drawCanvas.height);
      undoStack.length=0;
      prevPt=null; smoothPt=null;
      sel=null; renderSelectUI();
      exportBtn.disabled=true;
      writingSession.active=false;
      writingSession.controlLabel=null;
      writingSession.lastControlState="none";
      setState("已清空");
    });

    // 区域选择导出
    function getCanvasPointFromMouseEvent(ev){
      const rect = uiCanvas.getBoundingClientRect();
      const x = (ev.clientX-rect.left) * (uiCanvas.width/rect.width);
      const y = (ev.clientY-rect.top) * (uiCanvas.height/rect.height);
      return {x,y};
    }
    function normalizeSel(s){
      if(!s) return null;
      const x0=Math.min(s.x0,s.x1), y0=Math.min(s.y0,s.y1);
      const x1=Math.max(s.x0,s.x1), y1=Math.max(s.y0,s.y1);
      const W=uiCanvas.width, H=uiCanvas.height;
      return { x0:clamp(x0,0,W), y0:clamp(y0,0,H), x1:clamp(x1,0,W), y1:clamp(y1,0,H) };
    }
    function renderSelectUI(){
      const W=uiCanvas.width, H=uiCanvas.height;
      uctx.clearRect(0,0,W,H);
      if(!selecting || !sel) return;
      const s=normalizeSel(sel);
      if(!s) return;
      uctx.save();
      uctx.fillStyle="rgba(0,0,0,0.45)";
      uctx.fillRect(0,0,W,H);
      uctx.clearRect(s.x0,s.y0,s.x1-s.x0,s.y1-s.y0);
      uctx.strokeStyle="rgba(255,255,255,0.85)";
      uctx.lineWidth=2;
      uctx.strokeRect(s.x0+1,s.y0+1,(s.x1-s.x0)-2,(s.y1-s.y0)-2);
      uctx.restore();
    }
    function enterSelectMode(){
      selecting=true; sel=null; drag=null;
      exportBtn.disabled=true;
      cancelSelectBtn.disabled=false;
      selectBtn.classList.add("on");
      setState("选择区域（手势暂停）");
      renderSelectUI();
      syncSelText();
    }
    function exitSelectMode(){
      selecting=false; sel=null; drag=null;
      exportBtn.disabled=true;
      cancelSelectBtn.disabled=true;
      selectBtn.classList.remove("on");
      renderSelectUI();
      syncSelText();
    }
    selectBtn.addEventListener("click", ()=>{ selecting?exitSelectMode():enterSelectMode(); });
    cancelSelectBtn.addEventListener("click", ()=>exitSelectMode());

    uiCanvas.addEventListener("mousedown", (ev)=>{
      if(!selecting) return;
      const p=getCanvasPointFromMouseEvent(ev);
      drag={startX:p.x,startY:p.y};
      sel={x0:p.x,y0:p.y,x1:p.x,y1:p.y};
      renderSelectUI();
    });
    window.addEventListener("mousemove",(ev)=>{
      if(!selecting || !drag) return;
      const p=getCanvasPointFromMouseEvent(ev);
      sel.x1=p.x; sel.y1=p.y;
      renderSelectUI();
    });
    window.addEventListener("mouseup", ()=>{
      if(!selecting || !drag) return;
      drag=null;
      const s=normalizeSel(sel);
      const w=s?(s.x1-s.x0):0, h=s?(s.y1-s.y0):0;
      exportBtn.disabled = !(w>=10 && h>=10);
      renderSelectUI();
    });

    function downloadBlob(blob, filename){
      const a=document.createElement("a");
      const url=URL.createObjectURL(blob);
      a.href=url; a.download=filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(()=>URL.revokeObjectURL(url), 5000);
    }
    exportBtn.addEventListener("click", ()=>{
      if(!selecting || !sel) return;
      const s=normalizeSel(sel);
      if(!s) return;
      const w=Math.max(1, Math.round(s.x1-s.x0));
      const h=Math.max(1, Math.round(s.y1-s.y0));
      const off=document.createElement("canvas");
      off.width=w; off.height=h;
      const octx=off.getContext("2d");
      octx.fillStyle=bgColor;
      octx.fillRect(0,0,w,h);
      octx.drawImage(drawCanvas, s.x0,s.y0,w,h, 0,0,w,h);
      const ts=new Date();
      const name=`note_${ts.getFullYear()}${String(ts.getMonth()+1).padStart(2,"0")}${String(ts.getDate()).padStart(2,"0")}_${String(ts.getHours()).padStart(2,"0")}${String(ts.getMinutes()).padStart(2,"0")}${String(ts.getSeconds()).padStart(2,"0")}.png`;
      off.toBlob((blob)=>{ if(blob) downloadBlob(blob,name); }, "image/png");
    });

    // Handedness 标签（Left/Right）读取，尽量避免顺序抖动
    function getHandLabel(result, i){
      const hs = result.handednesses || result.handedness || null;
      const item = hs && hs[i] && hs[i][0] ? hs[i][0] : null;
      // tasks-vision 常见字段：categoryName 或 displayName
      return item ? (item.categoryName || item.displayName || null) : null;
    }

    async function initMediaPipe(){
      setState("加载 MediaPipe...");
      vision = await import("https://unpkg.com/@mediapipe/tasks-vision@0.10.14");
      ({ FilesetResolver, HandLandmarker, DrawingUtils } = vision);
      const fileset = await FilesetResolver.forVisionTasks("https://unpkg.com/@mediapipe/tasks-vision@0.10.14/wasm");
      handLandmarker = await HandLandmarker.createFromOptions(fileset, {
        baseOptions:{ modelAssetPath:"./hand_landmarker.task" },
        runningMode:"VIDEO",
        numHands:2,
        minHandDetectionConfidence:0.5,
        minHandPresenceConfidence:0.5,
        minTrackingConfidence:0.5
      });
      drawingUtils = new DrawingUtils(vctx);
      setState("MediaPipe 就绪");
    }

    async function openCamera(){
      setState("请求摄像头权限中...");
      stream = await navigator.mediaDevices.getUserMedia({
        video:{ facingMode:"user", width:{ideal:1920}, height:{ideal:1080}, frameRate:{ideal:30,max:60} },
        audio:false
      });
      video.srcObject = stream;
      await video.play();
      resizeToVideo();
      setState("运行中");
    }

    function controlStateOf(lm){
      if(isFist(lm)) return "fist";
      if(isIndexOnly(lm)) return "index";
      if(isOpenPalm(lm)) return "open";
      return "other";
    }

    function loop(){
      if(video.videoWidth && video.videoHeight) resizeToVideo();
      const W=viewCanvas.width, H=viewCanvas.height;

      const now = performance.now();
      const result = handLandmarker.detectForVideo(video, now);
      const hands = (result.landmarks && result.landmarks.length) ? result.landmarks : [];

      // 画视频（cover + 镜像）
      vctx.save();
      vctx.clearRect(0,0,W,H);
      vctx.fillStyle="#000";
      vctx.fillRect(0,0,W,H);
      const rect = calcCoverRect(video.videoWidth||W, video.videoHeight||H, W, H);
      vctx.translate(W,0);
      vctx.scale(-1,1);
      vctx.drawImage(video, rect.x, rect.y, rect.w, rect.h);
      vctx.restore();

      // 选择模式：暂停手势逻辑，但骨架继续画
      const blockGesture = selecting;

      if(!hands.length){
        if(now - lastSeenTs > HOLD_MS){ prevPt=null; smoothPt=null; }
        writingSession.active=false;
        writingSession.controlLabel=null;
        writingSession.lastControlState="none";
        setState(selecting ? "选择区域（手势暂停）" : "未检测到手");
        renderSelectUI();
        rafId=requestAnimationFrame(loop);
        return;
      }

      lastSeenTs = now;

      // 画骨架
      for(let i=0;i<hands.length;i++){
        const lm = hands[i];
        vctx.save();
        vctx.translate(W,0);
        vctx.scale(-1,1);
        drawingUtils.drawConnectors(lm, HandLandmarker.HAND_CONNECTIONS);
        drawingUtils.drawLandmarks(lm, { radius:3 });
        vctx.restore();
      }

      if(blockGesture){
        setState("选择区域（手势暂停）");
        renderSelectUI();
        rafId=requestAnimationFrame(loop);
        return;
      }

      // 构造 handInfo（含 label）
      const handInfo = hands.map((lm,i)=>({ lm, label:getHandLabel(result,i) }));

      // 手势逻辑
      let stateText = "等待手势";

      if(handInfo.length >= 2){
        // 尝试启动/维持“写字会话”
        if(!writingSession.active){
          // 仅当发现拳头手时启动会话
          const fistIdx = handInfo.findIndex(h => isFist(h.lm));
          if(fistIdx !== -1){
            writingSession.active = true;
            writingSession.controlLabel = handInfo[fistIdx].label; // 可能为 null，但仍能工作
            writingSession.lastControlState = "fist";
            prevPt = null; smoothPt = null;
          }
        }

        // 若会话激活：找到控制手与写字手
        if(writingSession.active){
          let controlIdx = -1;

          if(writingSession.controlLabel){
            controlIdx = handInfo.findIndex(h => h.label === writingSession.controlLabel);
          } else {
            // label 不可用时：退化为“优先找拳头/单食指/张开”来猜控制手
            controlIdx = handInfo.findIndex(h => isFist(h.lm));
            if(controlIdx === -1) controlIdx = handInfo.findIndex(h => isIndexOnly(h.lm));
            if(controlIdx === -1) controlIdx = handInfo.findIndex(h => isOpenPalm(h.lm));
          }

          if(controlIdx === -1){
            // 控制手丢失：结束会话
            writingSession.active=false;
            writingSession.controlLabel=null;
            writingSession.lastControlState="none";
            prevPt=null; smoothPt=null;
            stateText = "停止（控制手丢失）";
          } else {
            const writeIdx = (controlIdx === 0) ? 1 : 0;
            const controlLm = handInfo[controlIdx].lm;
            const writeLm = handInfo[writeIdx].lm;

            const curC = controlStateOf(controlLm);
            const prevC = writingSession.lastControlState;

            // 1) 撤回：仅在“写字会话”中，拳头->单食指
            const undoEdge = (prevC === "fist" && curC === "index" && (now - lastUndoTs) > UNDO_COOLDOWN_MS);
            if(undoEdge){
              lastUndoTs = now;
              doUndo();
              writingSession.lastControlState = curC;
              prevPt=null; smoothPt=null;
              stateText = "撤回（控制手：拳头→单食指）";
              setState(stateText);
              renderSelectUI();
              rafId=requestAnimationFrame(loop);
              return;
            }

            // 2) 停笔：写字会话中，拳头->张开
            const stopEdge = (prevC === "fist" && curC === "open");
            if(stopEdge){
              prevPt=null; smoothPt=null;
              writingSession.lastControlState = curC;
              stateText = "停笔（控制手：拳头→张开）";
              setState(stateText);
              renderSelectUI();
              rafId=requestAnimationFrame(loop);
              return;
            }

            // 3) 持续写字：控制手为拳头才画
            if(curC === "fist"){
              const midPx = indexMiddleMidpointPx(writeLm, W, H);
              const sp = smoothPoint(midPx);
              stateText = `写字（控制手=${controlIdx+1}，输出手=${writeIdx+1}）`;

              if(!prevPt){
                pushUndoSnapshot();
                prevPt = {x:sp.x,y:sp.y};
              }
              drawLineInterpolated(prevPt, sp, penW, penColor);
              prevPt = {x:sp.x,y:sp.y};
            } else {
              // 控制手非拳头：默认不画（避免误画），并断开
              prevPt=null; smoothPt=null;
              if(curC === "open") stateText = "停止（控制手张开）";
              else if(curC === "index") stateText = "停止（控制手单食指）";
              else stateText = "停止（控制手其它姿态）";
            }

            writingSession.lastControlState = curC;
          }
        } else {
          stateText = "停止（双手无拳头，未进入写字）";
          prevPt=null; smoothPt=null;
        }
      } else if(handInfo.length === 1){
        // 单手：拳头才是橡皮擦
        writingSession.active=false;
        writingSession.controlLabel=null;
        writingSession.lastControlState="none";

        const lm = handInfo[0].lm;
        if(isFist(lm)){
          const tip = indexTipPx(lm, W, H);
          const sp = smoothPoint(tip);
          stateText = "橡皮擦（单手拳头）";

          if(!prevPt){
            pushUndoSnapshot();
            prevPt = {x:sp.x,y:sp.y};
          }

          const dx=sp.x-prevPt.x, dy=sp.y-prevPt.y;
          const dist=Math.sqrt(dx*dx+dy*dy);
          const n=Math.max(1, Math.floor(dist/INTERP_STEP));
          for(let i=1;i<=n;i++){
            const t=i/n;
            eraseAt({ x:prevPt.x+dx*t, y:prevPt.y+dy*t });
          }
          prevPt = {x:sp.x,y:sp.y};
        } else {
          stateText = "停止（单手非拳头）";
          prevPt=null; smoothPt=null;
        }
      }

      setState(stateText);
      syncSelText();
      renderSelectUI();
      rafId=requestAnimationFrame(loop);
    }

    async function main(){
      try{
        setActiveColorBtn(penColor);
        setBgButtons();
        syncSelText();
        await initMediaPipe();
        await openCamera();
        loop();
      }catch(e){
        console.error(e);
        const msg=String(e).toLowerCase();
        if(msg.includes("permission") || msg.includes("denied")) setState("摄像头权限被拒绝（请在地址栏相机权限里允许）");
        else if(msg.includes("hand_landmarker.task")) setState("模型加载失败（确认 hand_landmarker.task 与 index.html 同目录且文件名一致）");
        else setState("初始化失败（网络/CDN/WASM，打开控制台看第一条报错）");
      }
    }

    window.addEventListener("beforeunload", ()=>{
      if(rafId) cancelAnimationFrame(rafId);
      if(stream) stream.getTracks().forEach(t=>t.stop());
    });

    main();
  </script>
</body>
</html>
