<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>hand_view_whiteboard</title>
  <style>
    body { margin: 18px; background: #000; color: #eee; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", sans-serif; }
    .wrap { max-width: 1100px; margin: 0 auto; }
    .panel { position: relative; width: 100%; background: #000; border-radius: 12px; overflow: hidden; box-shadow: 0 0 0 1px rgba(255,255,255,0.08) inset; }
    canvas { position: absolute; inset: 0; width: 100%; height: 100%; display: block; }
    .hud { margin-top: 12px; display: flex; gap: 12px; flex-wrap: wrap; align-items: center; }
    .badge { padding: 6px 10px; border-radius: 999px; background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.12); color: #eee; font-size: 14px; }
    .btn { padding: 8px 12px; border-radius: 10px; background: rgba(255,255,255,0.10); border: 1px solid rgba(255,255,255,0.18); color: #eee; font-size: 14px; cursor: pointer; user-select: none; }
    .btn:hover { background: rgba(255,255,255,0.14); }
    .hint { margin-top: 8px; color: rgba(255,255,255,0.72); font-size: 13px; line-height: 1.5; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="panel" id="panel">
      <canvas id="viewCanvas"></canvas>
      <canvas id="drawCanvas"></canvas>
    </div>
    <div class="hud">
      <span class="badge" id="status">状态：初始化中...</span>
      <span class="badge" id="mode">模式：--</span>
      <span class="badge" id="res">分辨率：--</span>
      <span class="badge" id="pen">笔宽：--</span>
      <span class="badge" id="dist">距离尺度：--</span>
      <button class="btn" id="clearBtn" type="button">清空画布</button>
    </div>
    <div class="hint">
      双手：任意一手为拳头=另一手持续写字（不管另一手做什么动作）；笔尖点=写字手“食指尖(8)与中指尖(12)中点”。笔粗细随靠近摄像头变粗、远离变细（自动校准）。<br>
      单手：不写（避免误触）。
    </div>
  </div>
  <video id="video" playsinline style="display:none;"></video>

  <script type="module">
    const panel = document.getElementById("panel");
    const viewCanvas = document.getElementById("viewCanvas");
    const drawCanvas = document.getElementById("drawCanvas");
    const vctx = viewCanvas.getContext("2d");
    const dctx = drawCanvas.getContext("2d");
    const video = document.getElementById("video");

    const statusEl = document.getElementById("status");
    const modeEl = document.getElementById("mode");
    const resEl = document.getElementById("res");
    const penEl = document.getElementById("pen");
    const distEl = document.getElementById("dist");
    const clearBtn = document.getElementById("clearBtn");

    function setStatus(t) { statusEl.textContent = "状态：" + t; }
    function setMode(t) { modeEl.textContent = "模式：" + t; }
    function setRes(t) { resEl.textContent = "分辨率：" + t; }
    function setPenW(w) { penEl.textContent = "笔宽：" + w.toFixed(1); }
    function setDist(t) { distEl.textContent = "距离尺度：" + t; }

    let stream = null;
    let rafId = null;

    let vision = null;
    let FilesetResolver = null;
    let HandLandmarker = null;
    let DrawingUtils = null;
    let handLandmarker = null;
    let drawingUtils = null;

    const PEN_COLOR = "#ff3b30";
    const BASE_PEN_W_MIN = 3.0;
    const BASE_PEN_W_MAX = 16.0;

    // 更“不断笔”
    const SMOOTH_ALPHA = 0.60;
    const HOLD_MS = 420;
    const INTERP_STEP = 2;

    let smoothPt = null;
    let prevPt = null;
    let lastSeenTs = 0;

    // 笔宽平滑
    let lastPenW = 7.0;

    // 自动校准 palmWidth 范围（只在“正在写字”时更新）
    let pwMin = Infinity;
    let pwMax = -Infinity;

    clearBtn.addEventListener("click", () => {
      dctx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
      prevPt = null;
      smoothPt = null;
      pwMin = Infinity; pwMax = -Infinity; // 清空后也重置校准，避免旧范围影响
    });

    function clamp01(x) { return Math.max(0, Math.min(1, x)); }

    function calcContainRect(srcW, srcH, dstW, dstH) {
      const srcAR = srcW / srcH;
      const dstAR = dstW / dstH;
      let w, h, x, y;
      if (srcAR > dstAR) { w = dstW; h = Math.round(dstW / srcAR); x = 0; y = Math.round((dstH - h) / 2); }
      else { h = dstH; w = Math.round(dstH * srcAR); y = 0; x = Math.round((dstW - w) / 2); }
      return { x, y, w, h };
    }

    function resizeToVideo() {
      const vw = video.videoWidth || 1280;
      const vh = video.videoHeight || 720;
      panel.style.aspectRatio = `${vw} / ${vh}`;
      if (viewCanvas.width !== vw) viewCanvas.width = vw;
      if (viewCanvas.height !== vh) viewCanvas.height = vh;
      if (drawCanvas.width !== vw) drawCanvas.width = vw;
      if (drawCanvas.height !== vh) drawCanvas.height = vh;
      setRes(`${vw}×${vh}`);
    }

    // 镜像：x 取 1-x
    function normToPixel(pt, w, h) { return { x: (1 - pt.x) * w, y: pt.y * h }; }

    function smoothPoint(pt) {
      if (!smoothPt) { smoothPt = { x: pt.x, y: pt.y }; return smoothPt; }
      smoothPt.x = smoothPt.x + (pt.x - smoothPt.x) * SMOOTH_ALPHA;
      smoothPt.y = smoothPt.y + (pt.y - smoothPt.y) * SMOOTH_ALPHA;
      return smoothPt;
    }

    function drawLineInterpolated(from, to, penW) {
      const dx = to.x - from.x, dy = to.y - from.y;
      const dist = Math.sqrt(dx*dx + dy*dy);
      const n = Math.max(1, Math.floor(dist / INTERP_STEP));
      dctx.save();
      dctx.globalCompositeOperation = "source-over";
      dctx.strokeStyle = PEN_COLOR;
      dctx.lineWidth = penW;
      dctx.lineCap = "round";
      dctx.lineJoin = "round";
      dctx.beginPath();
      dctx.moveTo(from.x, from.y);
      for (let i = 1; i <= n; i++) {
        const t = i / n;
        dctx.lineTo(from.x + dx * t, from.y + dy * t);
      }
      dctx.stroke();
      dctx.restore();
    }

    function fingerExtended(lm, mcp, pip, tip) {
      return (lm[tip].y < lm[pip].y) && (lm[tip].y < lm[mcp].y);
    }

    function isFist(lm) {
      const index = fingerExtended(lm, 5, 6, 8);
      const middle = fingerExtended(lm, 9, 10, 12);
      const ring = fingerExtended(lm, 13, 14, 16);
      const pinky = fingerExtended(lm, 17, 18, 20);
      return !index && !middle && !ring && !pinky;
    }

    // 近远代理：手掌宽（5 到 17）
    function palmWidth(lm) {
      const dx = lm[5].x - lm[17].x;
      const dy = lm[5].y - lm[17].y;
      return Math.hypot(dx, dy);
    }

    // 你要的“食指之间点”：这里实现为写字手 食指尖(8) 与 中指尖(12) 的中点
    function indexMiddleMidpointPx(lm, W, H) {
      const p8 = normToPixel(lm[8], W, H);
      const p12 = normToPixel(lm[12], W, H);
      return { x: (p8.x + p12.x) * 0.5, y: (p8.y + p12.y) * 0.5 };
    }

    function penWidthFromPalmAuto(pw) {
      // 更新校准范围（避免 Infinity/NaN）
      pwMin = Math.min(pwMin, pw);
      pwMax = Math.max(pwMax, pw);
      // 防止范围过窄导致不变化：给一个最小跨度
      const span = Math.max(0.04, pwMax - pwMin);
      const t = clamp01((pw - pwMin) / span); // 0远 1近
      const w = BASE_PEN_W_MIN + t * (BASE_PEN_W_MAX - BASE_PEN_W_MIN);
      lastPenW = lastPenW + (w - lastPenW) * 0.35;
      setDist(`pw=${pw.toFixed(3)} min=${(isFinite(pwMin)?pwMin:0).toFixed(3)} max=${(isFinite(pwMax)?pwMax:0).toFixed(3)}`);
      return lastPenW;
    }

    async function initMediaPipe() {
      setStatus("加载 MediaPipe（JS/WASM/模型）...");
      vision = await import("https://unpkg.com/@mediapipe/tasks-vision@0.10.14");
      ({ FilesetResolver, HandLandmarker, DrawingUtils } = vision);
      const fileset = await FilesetResolver.forVisionTasks("https://unpkg.com/@mediapipe/tasks-vision@0.10.14/wasm");
      handLandmarker = await HandLandmarker.createFromOptions(fileset, {
        baseOptions: { modelAssetPath: "./hand_landmarker.task" },
        runningMode: "VIDEO",
        numHands: 2,
        minHandDetectionConfidence: 0.5,
        minHandPresenceConfidence: 0.5,
        minTrackingConfidence: 0.5
      });
      drawingUtils = new DrawingUtils(vctx);
      setStatus("MediaPipe 就绪");
    }

    async function openCamera() {
      setStatus("请求摄像头权限中...");
      stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: "user", width: { ideal: 1920 }, height: { ideal: 1080 }, frameRate: { ideal: 30, max: 60 } },
        audio: false
      });
      video.srcObject = stream;
      await video.play();
      resizeToVideo();
      setStatus("摄像头已开启，运行中");
      setMode("等待手势");
    }

    function loop() {
      if (video.videoWidth && video.videoHeight) resizeToVideo();
      const W = viewCanvas.width, H = viewCanvas.height;

      vctx.save();
      vctx.clearRect(0, 0, W, H);
      vctx.fillStyle = "#000";
      vctx.fillRect(0, 0, W, H);
      const rect = calcContainRect(video.videoWidth || W, video.videoHeight || H, W, H);
      vctx.translate(W, 0);
      vctx.scale(-1, 1);
      vctx.drawImage(video, rect.x, rect.y, rect.w, rect.h);
      vctx.restore();

      const now = performance.now();
      const result = handLandmarker.detectForVideo(video, now);
      const hands = (result.landmarks && result.landmarks.length) ? result.landmarks : [];

      let mode = "等待手势";

      if (hands.length > 0) {
        lastSeenTs = now;

        for (const lm of hands) {
          vctx.save();
          vctx.translate(W, 0);
          vctx.scale(-1, 1);
          drawingUtils.drawConnectors(lm, HandLandmarker.HAND_CONNECTIONS);
          drawingUtils.drawLandmarks(lm, { radius: 3 });
          vctx.restore();
        }

        if (hands.length >= 2) {
          const fistFlags = hands.map(isFist);
          const fistIdx = fistFlags.findIndex(Boolean);

          if (fistIdx !== -1) {
            // 只要存在拳头，就用“另一手”输出笔；不再限制另一手是什么动作（哪怕也是拳头）
            const writeIdx = (fistIdx === 0) ? 1 : 0;
            const lm = hands[writeIdx];

            const pw = palmWidth(lm);
            const penW = penWidthFromPalmAuto(pw);
            setPenW(penW);

            // 你要的输出点：食指尖与中指尖的中点
            const midPx = indexMiddleMidpointPx(lm, W, H);
            const sp = smoothPoint(midPx);

            mode = `写字（拳头手=${fistIdx + 1}，输出手=${writeIdx + 1}，动作不限制）`;
            if (!prevPt) prevPt = { x: sp.x, y: sp.y };
            drawLineInterpolated(prevPt, sp, penW);
            prevPt = { x: sp.x, y: sp.y };
          } else {
            mode = "停止（双手但无拳头）";
            prevPt = null; smoothPt = null;
          }
        } else {
          mode = "停止（仅检测到单手）";
          prevPt = null; smoothPt = null;
        }
      } else {
        if (now - lastSeenTs > HOLD_MS) { prevPt = null; smoothPt = null; }
        mode = "未检测到手";
      }

      setMode(mode);
      rafId = requestAnimationFrame(loop);
    }

    async function main() {
      try { await initMediaPipe(); await openCamera(); loop(); }
      catch (e) {
        console.error(e);
        const msg = String(e).toLowerCase();
        if (msg.includes("permission") || msg.includes("denied")) setStatus("摄像头权限被拒绝（请在地址栏相机权限里允许）");
        else if (msg.includes("hand_landmarker.task")) setStatus("模型加载失败（确认 hand_landmarker.task 与 index.html 同目录且文件名一致）");
        else setStatus("初始化失败（可能是网络/CDN/WASM，打开控制台看第一条报错）");
      }
    }

    window.addEventListener("beforeunload", () => {
      if (rafId) cancelAnimationFrame(rafId);
      if (stream) stream.getTracks().forEach(t => t.stop());
    });

    main();
  </script>
</body>
</html>
